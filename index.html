<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>èªéŸ³åŠ ç¸½è¨ˆç®—æ©Ÿ</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Operator Row Styling */
        .operator-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 0px;
            /* Merged visually with below */
            padding: 0 16px;
        }

        .operator-btn {
            background: #4a90e2;
            /* Blue */
            border: none;
            border-radius: 12px;
            width: 100%;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .operator-btn svg {
            color: white;
            width: 32px;
            height: 32px;
            stroke-width: 3;
        }

        .operator-btn.active {
            background: #2c3e50;
            /* Dark when active */
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 2px solid #4a90e2;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header Controls (Settings + Top Ops) -->
        <div class="header-controls"
            style="display: flex; align-items: center; justify-content: space-between; padding: 10px 16px;">
            <!-- Top Operators: High Contrast -->
            <div class="top-operator-group" style="display: flex; gap: 12px;">
                <button class="icon-btn op-contrast active" data-op="+" aria-label="åŠ æ³•"
                    style="width: 42px; height: 42px; font-weight: 800;">ï¼‹</button>
                <button class="icon-btn op-contrast" data-op="-" aria-label="æ¸›æ³•"
                    style="width: 42px; height: 42px; font-weight: 800;">ï¼</button>
            </div>

            <!-- Right Controls: Keyboard + Settings -->
            <div class="right-controls-group" style="display: flex; gap: 8px;">
                <!-- Keyboard Input -->
                <button id="btn-keyboard" class="icon-btn op-contrast" aria-label="éµç›¤è¼¸å…¥"
                    style="width: 42px; height: 42px; display: flex; align-items: center; justify-content: center;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
                        <line x1="6" y1="8" x2="6" y2="8"></line>
                        <line x1="10" y1="8" x2="10" y2="8"></line>
                        <line x1="14" y1="8" x2="14" y2="8"></line>
                        <line x1="18" y1="8" x2="18" y2="8"></line>
                        <line x1="6" y1="12" x2="6" y2="12"></line>
                        <line x1="10" y1="12" x2="10" y2="12"></line>
                        <line x1="14" y1="12" x2="14" y2="12"></line>
                        <line x1="18" y1="12" x2="18" y2="12"></line>
                        <line x1="6" y1="16" x2="18" y2="16"></line>
                    </svg>
                </button>

                <!-- Settings -->
                <button id="btn-settings" class="settings-btn" aria-label="è¨­å®š">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path
                            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06-.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                        </path>
                    </svg>
                </button>
            </div>
        </div>

        <main id="entries-list" class="calc-list-container">
            <!-- Entries will be injected here -->
            <div class="empty-state">
                <div style="text-align: left; display: inline-block; max-width: 90%; line-height: 1.6;">
                    <p style="margin-bottom: 8px;">â— è«‹æŒ‰é–‹å§‹èªªè©±ï¼Œç›¸åŠ åªéœ€å–Šæ•¸å­—<br>
                        <span style="color: var(--text-secondary); font-size: 0.9em;">ä¾‹ã€Œ150 200 300ã€</span>
                    </p>
                    <p>â— èªªã€Œæ­¸é›¶ã€ã€Œå…¨æ¸…ã€ã€Œæ¸…é™¤ã€ã€Œå¹«æˆ‘æ­¸é›¶ã€ç•«é¢æœƒå…¨éƒ¨æ¸…é™¤</p>
                    <p style="margin-top: 8px; font-size: 0.8em; color: #888;">ç‰ˆæœ¬ v2.0 (é‹ç®—é¢æ¿)</p>
                </div>
            </div>
        </main>

        <div id="live-transcript" class="transcript-overlay hidden"></div>
        <div id="status-indicator" class="status-pill">é»æ“Šéº¥å…‹é¢¨</div>

        <div class="controls-area">
            <div class="app-controls">
                <!-- Operator Row (Moved Inside) -->
                <!-- Operator Row Removed -->

                <!-- Top Row: Total & Clear -->
                <div class="total-display-area">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button id="btn-clear-all" class="status-badge"
                            style="background: white; color: var(--primary-color); border: none; font-weight: bold; display: flex; align-items: center; gap: 4px; padding: 6px 12px; cursor: pointer;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M3 6h18"></path>
                                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                            </svg>
                            å…¨æ¸…
                        </button>
                        <!-- Larger x / buttons -->
                        <button class="icon-btn sm-btn op-contrast" data-op="*" aria-label="ä¹˜æ³•"
                            style="width: 38px; height: 38px; font-size: 1.2rem;">Ã—</button>
                        <button class="icon-btn sm-btn op-contrast" data-op="/" aria-label="é™¤æ³•"
                            style="width: 38px; height: 38px; font-size: 1.2rem;">Ã·</button>
                    </div>

                    <div style="text-align: right;">
                        <div class="total-label">ç¸½è¨ˆ (0 ç­†)</div>
                        <div class="total-amount">
                            <span style="font-size: 1rem; vertical-align: middle;">NT$</span>
                            <span id="total-amount">0</span>
                        </div>
                    </div>
                </div>

                <!-- Unified Bottom Control Row -->
                <div class="bottom-control-row"
                    style="display: flex; width: 100%; align-items: center; justify-content: space-between; padding: 0 1rem; margin-top: auto;">

                    <!-- Delete (Left) -->
                    <div style="flex: 1; display: flex; justify-content: flex-start; gap: 8px;">
                        <button id="btn-delete" class="secondary-btn btn-delete" aria-label="åˆªé™¤ä¸€ç­†"
                            style="width: 70px; height: 70px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path>
                                <line x1="18" y1="9" x2="12" y2="15"></line>
                                <line x1="12" y1="9" x2="18" y2="15"></line>
                            </svg>
                            <span>åˆªé™¤</span>
                        </button>
                    </div>

                    <!-- Mic (Center) -->
                    <div style="flex: 0 0 auto;">
                        <button id="mic-btn" class="mic-button" aria-label="é–‹å§‹/åœæ­¢ éŒ„éŸ³">
                            <div class="ripple-ring delay-1"></div>
                            <div class="ripple-ring"></div>
                            <div class="mic-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                    <line x1="12" y1="19" x2="12" y2="23"></line>
                                    <line x1="8" y1="23" x2="16" y2="23"></line>
                                </svg>
                            </div>
                        </button>
                    </div>

                    <!-- Summary (Right) -->
                    <div style="flex: 1; display: flex; justify-content: flex-end;">
                        <button id="btn-summary" class="secondary-btn btn-summary" aria-label="çµç®—"
                            style="width: 70px; height: 70px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <line x1="12" y1="1" x2="12" y2="23"></line>
                                <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                            </svg>
                            <span>çµç®—</span>
                        </button>
                    </div>

                </div>
            </div>

            <!-- Temporary Debug Bar -->
            <!-- Persistent Debug Bar -->
            <div id="debug-bar" style="
                position: fixed;
                display: none; /* Hidden by user request */
                bottom: 0;
                left: 0;
                width: 100%;
                z-index: 9999;
                padding: 12px;
                background: rgba(0, 0, 0, 0.9);
                color: #0f0;
                font-family: monospace;
                font-size: 14px;
                text-align: center;
                border-top: 1px solid #555;
                font-weight: bold;
                max-height: 15vh;
                overflow-y: auto;
            ">ç­‰å¾…å•Ÿå‹•... (è¨ºæ–·æ¨¡å¼)</div>
        </div>
    </div>

    </div>

    <!-- Settings Modal -->
    <div id="summary-modal" class="modal hidden">
        <div class="modal-content">
            <h2>çµç®—ç¸½è¦½</h2>
            <div class="modal-body">
                <div class="summary-row">
                    <span>ç¸½ç­†æ•¸</span>
                    <span id="modal-count" class="value">0</span>
                </div>
                <div class="summary-row total">
                    <span>ç¸½é‡‘é¡</span>
                    <span class="currency">NT$</span>
                    <span id="modal-total" class="value">0</span>
                </div>
            </div>
            <button id="close-modal-btn" class="primary-btn">é—œé–‰</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <h2>éº¥å…‹é¢¨è¨­å®š</h2>
            <div class="settings-body">
                <div class="settings-body">
                    <label for="auto-stop-select">é–’ç½®è‡ªå‹•é—œé–‰ (åˆ†é˜)</label>
                    <select id="auto-stop-select" class="styled-select">
                        <option value="1">1 åˆ†é˜</option>
                        <option value="2">2 åˆ†é˜</option>
                        <option value="3">3 åˆ†é˜</option>
                        <option value="5">5 åˆ†é˜</option>
                        <option value="10">10 åˆ†é˜</option>
                    </select>

                    <label for="rec-mode-select" style="margin-top: 15px; display: block;">è¾¨è­˜æ¨¡å¼ (ç’°å¢ƒè¨­å®š)</label>
                    <select id="rec-mode-select" class="styled-select">
                        <option value="continuous">é€£çºŒæ¨¡å¼ (é è¨­ - æµæš¢)</option>
                        <option value="single">å–®å¥æ¨¡å¼ (åµé›œç’°å¢ƒæ¨è–¦ - æº–ç¢º)</option>
                    </select>
                    <p style="font-size: 0.8rem; color: #888; margin-top: 5px;">
                        â€» è‹¥è¦ºå¾—åæ‡‰è®Šæ…¢æˆ–ç’°å¢ƒå¾ˆåµï¼Œè«‹åˆ‡æ›è‡³ã€Œå–®å¥æ¨¡å¼ã€ã€‚
                    </p>
                </div>
                <button id="save-settings-btn" class="primary-btn">å„²å­˜è¨­å®š</button>

                <!-- Troubleshooting Guide -->
                <div style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                    <h3 style="font-size: 0.95rem; color: #aaa; margin-bottom: 12px; font-weight: normal;">iPhone
                        ç„¡æ³•ä½¿ç”¨éº¥å…‹é¢¨ï¼Ÿ
                    </h3>
                    <ol style="font-size: 0.85rem; color: #888; padding-left: 20px; line-height: 1.6; margin: 0;">
                        <p class="step">1. é»æ“Šç¶²å€åˆ—å·¦å´çš„ <strong class="highlight">åœ–ç¤º</strong> (é€šå¸¸é¡¯ç¤ºç‚º <strong>Aa</strong> /
                            <strong>å¤§å°</strong> æˆ– <strong>é›»è…¦åœ–æ¡ˆ</strong>)
                        </p>
                        <p class="step warning">â€» è‹¥ä½¿ç”¨ LINE/FB é–‹å•Ÿï¼Œè«‹é»é¸ã€Œä½¿ç”¨ Safari é–‹å•Ÿã€</p>
                        <p class="step">2. é¸æ“‡ <strong class="highlight">ã€Œç¶²ç«™è¨­å®šã€</strong> (é€šå¸¸åœ¨é¸å–®ä¸‹æ–¹æˆ–æ˜¯ã€Œâ—â—â—ã€)</p>
                        <p class="step">3. å°‡ <strong class="highlight">ã€Œéº¥å…‹é¢¨ã€</strong> æ”¹ç‚º <strong
                                class="highlight">ã€Œå…è¨±ã€</strong></p>
                        <p class="step">4. é‡æ–°æ•´ç†ç¶²é </p>
                    </ol>

                    <h3 style="font-size: 0.95rem; color: #aaa; margin: 16px 0 12px; font-weight: normal;">Android
                        (Chrome)
                        ç„¡æ³•ä½¿ç”¨ï¼Ÿ
                    </h3>
                    <ol style="font-size: 0.85rem; color: #888; padding-left: 20px; line-height: 1.6; margin: 0;">
                        <li style="margin-bottom: 4px;">é»æ“Šç¶²å€åˆ—å·¦å´çš„ <strong>é–é ­åœ–ç¤º (ğŸ”’)</strong></li>
                        <li style="margin-bottom: 4px;">é¸æ“‡ <strong>ã€Œæ¬Šé™ã€</strong> æˆ– <strong>ã€Œç¶²ç«™è¨­å®šã€</strong></li>
                        <li style="margin-bottom: 4px;">é–‹å•Ÿ <strong>ã€Œéº¥å…‹é¢¨ã€</strong> æ¬Šé™</li>
                        <li>é‡æ–°æ•´ç†ç¶²é </li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- Keyboard Input Modal -->
        <div id="keyboard-modal" class="modal hidden">
            <div class="modal-content" style="padding-top: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="margin: 0; font-size: 1.2rem;">éµç›¤è¼¸å…¥</h2>
                    <button id="close-keyboard-btn"
                        style="background: none; border: none; color: #aaa; font-size: 1.5rem;">&times;</button>
                </div>

                <p style="text-align: left; color: #888; font-size: 0.9rem; margin-bottom: 8px;">
                    è«‹é»æ“Šä¸‹æ–¹æ¡†æ¡†ï¼Œä½¿ç”¨æ‚¨ç¿’æ…£çš„éµç›¤è¼¸å…¥æ³• (å¯ä½¿ç”¨éµç›¤ä¸Šçš„èªéŸ³è¼¸å…¥)ï¼š
                </p>

                <input type="text" id="manual-input-field"
                    style="width: 100%; font-size: 1.5rem; padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid #555; border-radius: 12px; color: white; margin-bottom: 20px;"
                    placeholder="ä¾‹å¦‚: 100 200">

                <div style="display: flex; gap: 10px;">
                    <button id="next-input-btn" class="primary-btn"
                        style="flex: 2; background: linear-gradient(135deg, #3b82f6, #2563eb); font-size: 1.1rem;">ä¸‹ä¸€ç­†
                        (åŠ å…¥)</button>
                    <button id="finish-input-btn" class="secondary-btn"
                        style="flex: 1; border: 1px solid #555;">å®Œæˆ</button>
                </div>
            </div>
        </div>



        <script>
            class VoiceCalculator {
                constructor() {
                    this.entries = [];
                    this.recognition = null;
                    this.isListening = false;
                    this.finalTranscript = '';
                    this.silenceTimer = null;
                    this.autoStopMinutes = 3; // Default 3 mins
                    this.silenceThreshold = 250; // Challenge: 0.25s Super Fast
                    this.recognitionMode = 'continuous'; // 'continuous' or 'single'
                    this.lastSpeechTime = Date.now();
                    this.inactivityCheckInterval = null;
                    this.entriesList = document.getElementById('entries-list');
                    this.micBtn = document.getElementById('mic-btn');
                    this.statusIndicator = document.getElementById('status-indicator');
                    this.totalAmountEl = document.getElementById('total-amount');
                    this.modalTotal = document.getElementById('modal-total');
                    this.modalCount = document.getElementById('modal-count');
                    this.settingsBtn = document.getElementById('btn-settings');
                    this.summaryModal = document.getElementById('summary-modal');

                    // Arithmetic Logic State
                    this.currentOperator = '+'; // Default mode
                    this.operatorButtons = document.querySelectorAll('.icon-btn[data-op]');

                    // Wake Lock
                    this.wakeLock = null;

                    // Timers (moved from original position, but kept for clarity if needed later)
                    this.transcriptTimeout = null;
                    this.forceFinalizeTimer = null;
                    this.restartTimer = null;
                    this.inactivityTimer = null; // Auto-stop timer

                    // DOM Elements (remaining from original)
                    this.totalAreaLabel = document.querySelector('.total-label');
                    this.closeModalBtn = document.getElementById('close-modal-btn');
                    this.liveTranscript = document.getElementById('live-transcript');

                    // Buttons
                    this.btnDelete = document.getElementById('btn-delete');
                    this.btnSummary = document.getElementById('btn-summary');
                    this.btnClear = document.getElementById('btn-clear-all');

                    this.initSpeechRecognition();
                    if (this.micBtn) {
                        this.initListeners();
                        this.initOperatorButtons();
                        this.initWakeLock();
                        this.enableWakeLockOnInteraction();
                    }
                    this.render();
                    this.updateOperatorUI(); // Set initial active state and hint
                }

                initOperatorButtons() {
                    // Support both old class (for safety) and new class
                    const ops = document.querySelectorAll('.operator-btn, .icon-btn[data-op]');
                    ops.forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.currentOperator = btn.dataset.op;
                            this.updateOperatorUI();
                            if (navigator.vibrate) navigator.vibrate(30);
                        });
                    });
                }

                updateOperatorUI() {
                    document.querySelectorAll('.operator-btn, .icon-btn[data-op]').forEach(btn => {
                        if (btn.dataset.op === this.currentOperator) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // Update hints
                    const hint = document.getElementById('mode-hint');
                    if (hint) {
                        const textMap = { '+': 'åŠ æ³• (é è¨­)', '-': 'æ¸›æ³•', '*': 'ä¹˜æ³• (ä»¥ç¸½è¨ˆä¹˜)', '/': 'é™¤æ³• (ä»¥ç¸½è¨ˆé™¤)' };
                        hint.textContent = textMap[this.currentOperator] || 'åŠ æ³•';
                    }
                }

                resetInactivityTimer() {
                    if (this.inactivityTimer) clearTimeout(this.inactivityTimer);

                    if (this.isListening) {
                        const ms = this.autoStopMinutes * 60 * 1000;
                        this.inactivityTimer = setTimeout(() => {
                            console.log('Inactivity timeout reached.');
                            this.isListening = false;
                            this.recognition.stop();
                            this.updateUIState(false);
                            this.statusIndicator.textContent = 'é–’ç½®å·²é—œé–‰';
                            if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
                        }, ms);
                    }
                }

                initSpeechRecognition() {
                    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        this.recognition = new SpeechRecognition();

                        // Protocol Check (Crucial for Mobile & Local File)
                        if (location.protocol === 'file:') {
                            setTimeout(() => {
                                if (confirm('âš ï¸ã€è­¦å‘Šï¼šæª”æ¡ˆæ¨¡å¼ä¸ç©©å®šã€‘\n\næ‚¨ç›´æ¥é–‹å•Ÿäº† index.html (File æ¨¡å¼)ã€‚\nGoogle Chrome åœ¨æ­¤æ¨¡å¼ä¸‹æœƒé »ç¹åˆ‡æ–·éº¥å…‹é¢¨ã€‚\n\nå¼·çƒˆå»ºè­°ï¼š\nè«‹åŸ·è¡Œè³‡æ–™å¤¾å…§çš„ã€Œstart_server.batã€ä¾†å•Ÿå‹•ï¼Œ\næ‰èƒ½ä¿è­‰éº¥å…‹é¢¨ç©©å®šä¸æ–·ç·šã€‚')) {
                                    // optional action
                                }
                                this.statusIndicator.textContent = 'æª”æ¡ˆæ¨¡å¼ (æ˜“æ–·ç·š)';
                                this.statusIndicator.style.color = 'orange';
                                const db = document.getElementById('debug-bar');
                                if (db) db.textContent = 'âŒ åš´é‡è­¦å‘Šï¼šFile æ¨¡å¼ä¸‹éº¥å…‹é¢¨æ¥µä¸ç©©å®šï¼Œè«‹æ”¹ç”¨ Server å•Ÿå‹•';
                            }, 500);
                        } else if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                            setTimeout(() => {
                                alert('â›”ã€éº¥å…‹é¢¨å—é™æ³¨æ„ã€‘â›”\n\næ‚¨ä¼¼ä¹æ­£åœ¨ä½¿ç”¨ã€Œéå®‰å…¨é€£ç·š (HTTP)ã€é–‹å•Ÿæ­¤ç¶²é ã€‚\n\næ‰‹æ©Ÿç€è¦½å™¨é€šå¸¸æœƒå¼·åˆ¶å°é–éº¥å…‹é¢¨ã€‚\nè«‹å˜—è©¦ï¼š\n1. ä½¿ç”¨ localhost (æœ¬æ©Ÿ)\n2. è¨­å®š HTTPS Server\n3. ä½¿ç”¨éµç›¤è¼¸å…¥æ¨¡å¼');
                                this.statusIndicator.textContent = 'é€£ç·šä¸å®‰å…¨ (éº¥å…‹é¢¨å—é™)';
                                this.statusIndicator.style.color = 'orange';
                            }, 500);
                        }

                        // Mode Configuration
                        if (this.recognitionMode === 'single') {
                            this.recognition.continuous = false;
                        } else {
                            this.recognition.continuous = true;
                        }

                        this.recognition.lang = 'cmn-Hant-TW';
                        this.recognition.interimResults = true;
                        this.recognition.maxAlternatives = 1;

                        this.recognition.onstart = () => {
                            console.log('Voice Service: Started');
                            const db = document.getElementById('debug-bar');
                            if (db) { db.textContent = 'ğŸŸ¢ æœå‹™å•Ÿå‹• (Listening)...'; db.style.color = '#0f0'; }

                            if (this.isListening) {
                                this.updateUIState(true);
                                if (navigator.vibrate) navigator.vibrate(50);
                                this.resetInactivityTimer();
                            }
                        };

                        // Diagnostic Events
                        this.recognition.onaudiostart = () => { if (document.getElementById('debug-bar')) document.getElementById('debug-bar').textContent = 'ğŸµ éŸ³è¨Šè¼¸å…¥é–‹å§‹ (Audio Start)'; };
                        this.recognition.onsoundstart = () => {
                            const db = document.getElementById('debug-bar');
                            if (db) { db.textContent = 'ğŸ”Š åµæ¸¬åˆ°è²éŸ³ (Sound Detected)'; db.style.color = '#fff'; }
                        };
                        this.recognition.onspeechstart = () => {
                            const db = document.getElementById('debug-bar');
                            if (db) { db.textContent = 'ğŸ—£ï¸ åµæ¸¬åˆ°èªéŸ³ (Speech Start)'; db.style.color = 'yellow'; }
                        };
                        this.recognition.onnomatch = (e) => {
                            if (document.getElementById('debug-bar')) document.getElementById('debug-bar').textContent = 'â“ ç„¡æ³•è¾¨è­˜ (No Match)';
                        };

                        this.recognition.onend = () => {
                            const db = document.getElementById('debug-bar');
                            if (db) { db.textContent = 'ğŸ”´ æœå‹™åœæ­¢ (Enter)'; db.style.color = '#aaa'; }
                            console.log('Voice Service: Ended');
                            // Vital: If we are supposed to be listening, restart immediately.
                            if (this.isListening) {
                                console.log('Voice Service: Auto-restarting...');

                                clearTimeout(this.restartTimer);

                                // Loop Protection
                                const now = Date.now();
                                if (!this.restartTimestamps) this.restartTimestamps = [];
                                this.restartTimestamps.push(now);
                                // Keep only last 2 seconds
                                this.restartTimestamps = this.restartTimestamps.filter(t => now - t < 2000);

                                if (this.restartTimestamps.length > 5) {
                                    console.error("Refresh Loop Detected");
                                    this.isListening = false;
                                    this.updateUIState(false);
                                    alert('âš ï¸ éº¥å…‹é¢¨é »ç¹æ–·ç·š\n\nç€è¦½å™¨ä¼¼ä¹é˜»æ“‹äº†éº¥å…‹é¢¨ã€‚è«‹å˜—è©¦ï¼š\n1. é‡æ–°æ•´ç†ç¶²é \n2. æª¢æŸ¥ç¶²å€åˆ—æ˜¯å¦å…è¨±æ¬Šé™\n3. æ”¹ç”¨ start_server.bat å•Ÿå‹•');
                                    return;
                                }

                                this.restartTimer = setTimeout(() => {
                                    try {
                                        if (this.isListening) this.recognition.start();
                                    } catch (e) {
                                        console.error("Restart failed", e);
                                    }
                                }, 50);
                            } else {
                                this.updateUIState(false);
                            }
                        };

                        this.recognition.onresult = (event) => {
                            this.resetInactivityTimer();
                            clearTimeout(this.forceFinalizeTimer);

                            let finalTranscript = '';
                            let interimTranscript = '';

                            for (let i = event.resultIndex; i < event.results.length; ++i) {
                                if (event.results[i].isFinal) {
                                    finalTranscript += event.results[i][0].transcript;
                                } else {
                                    interimTranscript += event.results[i][0].transcript;
                                }
                            }

                            if (finalTranscript) {
                                this.showTranscript(finalTranscript);
                                this.processSpeechInput(finalTranscript);
                            }

                            if (interimTranscript) {
                                this.showTranscript(interimTranscript);

                                // Eager Command Execution:
                                // If the user says a command, execute it immediately without waiting for finalization.
                                if (this.isCommand(interimTranscript)) {
                                    console.log(`Eager Command Triggered: ${interimTranscript}`);
                                    this.processSpeechInput(interimTranscript);

                                    // Small delay before aborting to ensure UI updates are seen
                                    setTimeout(() => this.recognition.abort(), 100);
                                    return;
                                }

                                // Force finalize logic (Universal 250ms)
                                // User request: "0.4s feels slow", trying 0.25s
                                this.forceFinalizeTimer = setTimeout(() => {
                                    console.log(`Force Finalizing: ${interimTranscript}`);
                                    if (this.isListening) this.recognition.stop();
                                }, 250);
                            }
                        };

                        this.recognition.onerror = (event) => {
                            console.log(`Voice Service Error: ${event.error}`);
                            const db = document.getElementById('debug-bar');

                            // Show error clearly
                            if (db) {
                                // Translate common errors
                                const errMap = {
                                    'no-speech': 'æ²’è½åˆ°è²éŸ³ (No Speech)',
                                    'network': 'ç¶²è·¯éŒ¯èª¤ (Network)',
                                    'not-allowed': 'æ²’æ¬Šé™ (Blocked)',
                                    'aborted': 'å·²ä¸­æ­¢ (Aborted)'
                                };
                                db.textContent = `âŒ éŒ¯èª¤: ${errMap[event.error] || event.error}`;
                                db.style.color = '#ef4444';
                            }

                            // Network error is common on mobile if connection is unstable
                            if (event.error === 'network') {
                                this.statusIndicator.textContent = 'ç¶²è·¯ä¸ç©© (éœ€é€£ç¶²)';
                                this.statusIndicator.style.color = '#ef4444';
                                return;
                            }

                            if (event.error === 'no-speech') {
                                // Ignore, but let debug bar show it
                                return;
                            }

                            if (event.error === 'aborted') return;

                            if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                                this.isListening = false;
                                this.updateUIState(false);
                                alert('âš ï¸ ç„¡æ³•å­˜å–éº¥å…‹é¢¨\n\nç³»çµ±å°‡è‡ªå‹•é–‹å•Ÿã€Œéº¥å…‹é¢¨è¨­å®šã€æ•™å­¸ï¼Œè«‹ä¾ç…§æ­¥é©Ÿé–‹å•Ÿæ¬Šé™ã€‚');
                                const settingsModal = document.getElementById('settings-modal');
                                if (settingsModal) settingsModal.classList.remove('hidden');
                            } else {
                                this.statusIndicator.textContent = 'éŒ¯èª¤: ' + event.error;
                            }
                        };
                    } else {
                        alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¾¨è­˜ï¼Œè«‹ä½¿ç”¨ Chrome (Android) æˆ– Safari (iOS)ã€‚');
                        this.micBtn.disabled = true;
                    }
                }

                async initWakeLock() {
                    if ('wakeLock' in navigator) {
                        try {
                            this.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock is active!');

                            this.wakeLock.addEventListener('release', () => {
                                console.log('Wake Lock released');
                            });

                            // Re-acquire on visibility change
                            document.addEventListener('visibilitychange', async () => {
                                if (this.wakeLock !== null && document.visibilityState === 'visible') {
                                    try {
                                        this.wakeLock = await navigator.wakeLock.request('screen');
                                        console.log('Wake Lock re-acquired');
                                    } catch (e) { console.log('Re-acquire failed', e); }
                                }
                            });
                        } catch (err) {
                            console.error(`${err.name}, ${err.message}`);
                        }
                    }
                }

                enableWakeLockOnInteraction() {
                    const unlockWakeLock = async () => {
                        if (!this.wakeLock) {
                            await this.initWakeLock();
                            if (this.wakeLock) {
                                document.removeEventListener('click', unlockWakeLock);
                                document.removeEventListener('touchstart', unlockWakeLock);
                            }
                        }
                    };
                    document.addEventListener('click', unlockWakeLock);
                    document.addEventListener('touchstart', unlockWakeLock);
                }

                initListeners() {
                    // Settings Button Logic
                    if (this.settingsBtn) {
                        const settingsModal = document.getElementById('settings-modal');
                        const saveSettingsBtn = document.getElementById('save-settings-btn');
                        const autoStopSelect = document.getElementById('auto-stop-select');
                        const recModeSelect = document.getElementById('rec-mode-select');

                        this.settingsBtn.addEventListener('click', () => {
                            settingsModal.classList.remove('hidden');
                            autoStopSelect.value = this.autoStopMinutes;
                            recModeSelect.value = this.recognitionMode;
                        });

                        saveSettingsBtn.addEventListener('click', () => {
                            const val = parseInt(autoStopSelect.value);
                            this.autoStopMinutes = val;

                            const newMode = recModeSelect.value;
                            if (this.recognitionMode !== newMode) {
                                this.recognitionMode = newMode;
                                // Update threshold: Universal 250
                                this.silenceThreshold = 250;

                                // Restart if running
                                if (this.isListening) {
                                    this.isListening = false;
                                    this.recognition.abort();
                                    setTimeout(() => this.micBtn.click(), 500); // Re-trigger
                                }
                            }

                            settingsModal.classList.add('hidden');
                            this.showTranscript(`å·²å„²å­˜: ${val}åˆ† / ${newMode === 'single' ? 'å–®å¥' : 'é€£çºŒ'}`);
                            if (this.isListening) this.resetInactivityTimer();
                        });

                        settingsModal.addEventListener('click', (e) => {
                            if (e.target === settingsModal) settingsModal.classList.add('hidden');
                        });
                    }

                    this.micBtn.addEventListener('click', () => {
                        if (navigator.vibrate) navigator.vibrate(30);

                        if (this.isListening) {
                            // User wants to STOP
                            this.isListening = false;
                            this.recognition.stop();
                            this.updateUIState(false);
                            if (this.inactivityTimer) clearTimeout(this.inactivityTimer);
                        } else {
                            // User wants to START
                            this.isListening = true;
                            this.statusIndicator.textContent = 'å•Ÿå‹•ä¸­...';
                            try {
                                this.recognition.abort();
                            } catch (e) { }

                            // Direct start (No timeout) for better mobile compatibility
                            try {
                                this.recognition.start();
                            } catch (e) {
                                console.error("Start failed", e);
                                this.isListening = false;
                                this.updateUIState(false);
                                // Only alert if not already started
                                if (e.message !== "Failed to execute 'start' on 'SpeechRecognition': recognition has already started.") {
                                    alert('å•Ÿå‹•å¤±æ•—ï¼Œè«‹é‡è©¦ (æˆ–å˜—è©¦é‡æ•´ç¶²é )');
                                }
                            }
                        }
                    });

                    this.btnDelete.addEventListener('click', () => this.deleteLastEntry());
                    this.btnSummary.addEventListener('click', () => this.showSummary());

                    this.btnClear.addEventListener('click', () => {
                        if (this.entries.length > 0 && confirm('ç¢ºå®šæ¸…ç©ºæ‰€æœ‰æ•¸å­—ï¼Ÿ')) {
                            this.clearAllEntries();
                        } else if (this.entries.length === 0) {
                            this.showTranscript('ç„¡è³‡æ–™');
                        }
                    });

                    this.closeModalBtn.addEventListener('click', () => this.summaryModal.classList.add('hidden'));
                    this.closeModalBtn.addEventListener('click', () => this.summaryModal.classList.add('hidden'));
                    this.summaryModal.addEventListener('click', (e) => {
                        if (e.target === this.summaryModal) this.summaryModal.classList.add('hidden');
                    });

                    // Keyboard Modal Logic
                    const keyModal = document.getElementById('keyboard-modal');
                    const keyBtn = document.getElementById('btn-keyboard');
                    const closeKeyBtn = document.getElementById('close-keyboard-btn');
                    const inputField = document.getElementById('manual-input-field');
                    const confirmKeyBtn = document.getElementById('next-input-btn'); // Replaced ID
                    const finishKeyBtn = document.getElementById('finish-input-btn');

                    if (keyBtn) {
                        keyBtn.addEventListener('click', () => {
                            keyModal.classList.remove('hidden');
                            setTimeout(() => inputField.focus(), 100);
                        });
                    }

                    const processManualInput = (keepOpen = false) => {
                        const text = inputField.value;
                        if (text) {
                            this.processSpeechInput(text);
                            inputField.value = '';
                            if (navigator.vibrate) navigator.vibrate(50);
                        }

                        if (keepOpen) {
                            inputField.focus();
                        } else {
                            keyModal.classList.add('hidden');
                        }
                    };

                    if (closeKeyBtn) closeKeyBtn.addEventListener('click', () => keyModal.classList.add('hidden'));
                    keyModal.addEventListener('click', (e) => {
                        if (e.target === keyModal) keyModal.classList.add('hidden');
                    });

                    // Bindings
                    if (confirmKeyBtn) confirmKeyBtn.addEventListener('click', () => processManualInput(true)); // Next
                    if (finishKeyBtn) finishKeyBtn.addEventListener('click', () => processManualInput(false)); // Finish

                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') processManualInput(true); // Enter = Next (Continuous)
                    });
                }

                initOperatorButtons() {
                    this.operatorButtons.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            // Remove active from all
                            this.operatorButtons.forEach(b => b.classList.remove('active'));
                            // Add to clicked
                            const target = e.currentTarget;
                            target.classList.add('active');
                            // Set state
                            this.currentOperator = target.dataset.op;

                            // Feedback
                            if (navigator.vibrate) navigator.vibrate(30);

                            // Update UI Text
                            this.updateOperatorUI();
                        });
                    });
                }

                updateOperatorUI() {
                    // Ensure visual sync
                    this.operatorButtons.forEach(btn => {
                        if (btn.dataset.op === this.currentOperator) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // Update text hint if exists
                    const hint = document.getElementById('mode-hint');
                    if (hint) {
                        const map = { '+': 'åŠ æ³•', '-': 'æ¸›æ³•', '*': 'ä¹˜æ³• (ç¸½é¡)', '/': 'é™¤æ³• (ç¸½é¡)' };
                        hint.textContent = map[this.currentOperator] || 'åŠ æ³•';
                        hint.style.color = this.currentOperator === '+' ? '#3b82f6' :
                            this.currentOperator === '-' ? '#ef4444' :
                                this.currentOperator === '*' ? '#f59e0b' : '#8b5cf6';
                    }
                }

                updateUIState(listening, customText) {
                    if (listening) {
                        this.micBtn.classList.add('listening');
                        this.statusIndicator.textContent = customText || 'è†è½ä¸­...';
                        this.statusIndicator.classList.add('listening');
                    } else {
                        this.micBtn.classList.remove('listening');
                        this.statusIndicator.textContent = 'ç³»çµ±å·²æ›´æ–° (æº–å‚™å°±ç·’)';
                        setTimeout(() => {
                            this.updateUIState(false);
                        }, 2000);
                        this.statusIndicator.classList.remove('listening');
                        this.hideTranscript();
                    }
                }

                showTranscript(text) {
                    this.liveTranscript.textContent = text;
                    this.liveTranscript.classList.remove('hidden');
                    if (this.transcriptTimeout) clearTimeout(this.transcriptTimeout);
                    this.transcriptTimeout = setTimeout(() => this.hideTranscript(), 2000);
                }

                hideTranscript() {
                    this.liveTranscript.classList.add('hidden');
                }

                isCommand(text) {
                    if (!text) return false;
                    const lower = text.toLowerCase();
                    return text.includes('æ¸…é™¤') || text.includes('å…¨æ¸…') || text.includes('æ­¸é›¶') || text.includes('æ¸…æ¥š') || text.includes('æ­¸0') || text.includes('å¹«æˆ‘æ­¸é›¶') ||
                        text.includes('ç¸½å…±') || text.includes('å¤šå°‘') || text.includes('çµç®—') || text.includes('è²·å–®') || text.includes('æ­¤å–®') ||
                        text.includes('åˆªé™¤') || lower.includes('delete');
                }

                processSpeechInput(text) {
                    let cleanText = text.trim();
                    cleanText = cleanText.replace(/,/g, '');
                    if (!cleanText) return;

                    // --- Debug Logging (Raw) ---
                    const debugBar = document.getElementById('debug-bar');
                    if (debugBar) {
                        debugBar.textContent = `è½è¦‹: ${cleanText} | æ¨¡å¼: ${this.currentOperator}`;
                    }

                    // Command: Delete
                    if (cleanText.includes('åˆªé™¤') || cleanText.toLowerCase().includes('delete')) {
                        this.deleteLastEntry();
                        return;
                    }

                    // Command: Clear All
                    if (cleanText.includes('æ¸…é™¤') || cleanText.includes('å…¨æ¸…') || cleanText.includes('æ­¸é›¶') || cleanText.includes('æ¸…æ¥š') || cleanText.includes('æ­¸0') || cleanText.includes('å¹«æˆ‘æ­¸é›¶')) {
                        this.clearAllEntries();
                        return;
                    }

                    // Command: Summary
                    if (cleanText.includes('ç¸½å…±') || cleanText.includes('å¤šå°‘') || cleanText.includes('çµç®—') || cleanText.includes('è²·å–®') || cleanText.includes('æ­¤å–®')) {
                        this.showSummary();
                        return;
                    }

                    // --- Batch Input Pre-processing (Quantifiers) ---
                    // Pattern: "3å€‹100" or "ä¸‰å€‹100" -> "100 100 100"
                    // Logic: Capture Number (Digit/Chinese) + Quantifier + Number (Digit/Chinese)

                    // --- Deduplicate Quantifier Phrases (Android Guard) ---
                    // Fixes "3å€‹300 3å€‹300" -> "3å€‹300" (Prevents double counting)
                    const phraseDedupRegex = /(([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+)\s*[å€‹é¡†åªæ¢å¼µ]\s*([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+))\s+\1/g;
                    cleanText = cleanText.replace(phraseDedupRegex, "$1");

                    // Pattern 1: Prefix "3å€‹100" -> "100 100 100"
                    // Enhanced with Stutter Guard: "3å€‹ 500 500" (ASR Artifact) -> Consumes both, returns 3x 500
                    const prefixQuantifiereRegex = /([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+)\s*[å€‹é¡†åªæ¢å¼µ]\s*([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+)(?:\s+\2)?/g;
                    cleanText = cleanText.replace(prefixQuantifiereRegex, (match, countStr, valueStr) => {
                        const count = this.parseNumber(countStr);
                        const value = this.parseNumber(valueStr);
                        if (!isNaN(count) && !isNaN(value) && count > 0 && count <= 50) {
                            return Array(count).fill(value).join(' ');
                        }
                        return match; // If parse failed, return original (stutter might remain but better than breaking)
                    });

                    // Pattern 2: Suffix "100 5å€‹" -> "100 100 100 100 100"
                    // Useful for "misrecognized" order or natural "Item first" speaking style
                    const suffixQuantifierRegex = /([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+)\s+([0-9\.]+|[é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬]+)\s*[å€‹é¡†åªæ¢å¼µ]/g;
                    cleanText = cleanText.replace(suffixQuantifierRegex, (match, valueStr, countStr) => {
                        const count = this.parseNumber(countStr);
                        const value = this.parseNumber(valueStr);
                        if (!isNaN(count) && !isNaN(value) && count > 0 && count <= 50) {
                            // Debug log if we hit this fallback
                            const debugBar = document.getElementById('debug-bar');
                            if (debugBar) debugBar.textContent += ` | æ•æ‰å€’è£: ${count}å€‹${value}`;
                            return Array(count).fill(value).join(' ');
                        }
                        return match;
                    });

                    // --- Arithmetic Pre-processing ---
                    // We keep the old normalization just in case, but we prioritize the UI operator
                    cleanText = cleanText.replace(/æ¸›å»|æ‰£æ‰|æ‰£é™¤|æ¸›|â–|ï¼|ï¹£/g, ' - ');
                    cleanText = cleanText.replace(/ä¹˜ä»¥|ä¹˜ä¸Š|ä¹˜|âœ–ï¸|x|X|æˆ|Ã—|ï¼Š|ï¼¸|ï½˜/g, ' * ');
                    cleanText = cleanText.replace(/é™¤ä»¥|é™¤|â—|Ã·|ï¼/g, ' / ');
                    cleanText = cleanText.replace(/åŠ |ï¼‹/g, ' + ');
                    cleanText = cleanText.replace(/é»|ã€‚|ï¼|Â·/g, '.');

                    // Split by anything that isn't a Number char, Operator, or Dot
                    const tokens = cleanText.split(/[^0-9é›¶ä¸€äºŒå…©ä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬\.\-\*\/\+]+/);

                    if (debugBar) {
                        debugBar.textContent += ` | è™•ç†å¾Œ: ${cleanText} | Token: [${tokens.join(', ')}]`;
                    }

                    let addedCount = 0;
                    let bufferExpression = [];

                    const flushBuffer = () => {
                        if (bufferExpression.length > 0) {
                            try {
                                const result = this.evaluateExpression(bufferExpression);
                                if (result !== null && !isNaN(result)) {
                                    // Determine display label for * and /
                                    let label = null;
                                    if (bufferExpression.length >= 2) {
                                        const op = bufferExpression[0];
                                        const val = bufferExpression[bufferExpression.length - 1]; // Approximate
                                        if (op === '*' && typeof val === 'number') label = `Ã— ${val}`;
                                        else if (op === '/' && typeof val === 'number') label = `Ã· ${val}`;
                                    }

                                    this.addEntry(result, label);
                                    addedCount++;
                                    if (debugBar) debugBar.textContent += ` | çµæœ: ${result}`;
                                } else {
                                    if (debugBar) debugBar.textContent += ` | ç„¡æ•ˆé‹ç®—`;
                                }
                            } catch (e) {
                                if (debugBar) debugBar.textContent += ` | éŒ¯èª¤: ${e.message}`;
                            }
                            bufferExpression = [];
                        }
                    };

                    tokens.forEach(token => {
                        token = token.trim();
                        if (!token) return;

                        // If token is an operator (explicitly spoken)
                        if (['-', '*', '/', '+'].includes(token)) {
                            // If there's a number before this operator, flush it first
                            if (bufferExpression.length > 0 && typeof bufferExpression[bufferExpression.length - 1] === 'number') {
                                flushBuffer();
                            }
                            bufferExpression.push(token);
                            return;
                        }

                        // Attempt number parse
                        let val = this.parseNumber(token);

                        // If valid number
                        if (!isNaN(val)) {
                            // Apply Current Operator Logic if no explicit operator was spoken
                            // If buffer is empty or the last token was a number (implying a new operation)
                            // and the current operator is not '+', prepend the current operator.
                            if (this.currentOperator !== '+' && (bufferExpression.length === 0 || typeof bufferExpression[bufferExpression.length - 1] === 'number')) {
                                // If the last item was a number, flush it first to start a new operation
                                if (typeof bufferExpression[bufferExpression.length - 1] === 'number') {
                                    flushBuffer();
                                }
                                bufferExpression.push(this.currentOperator);
                            }

                            // Check if previous item in buffer was ALSO a number (Implicit break)
                            // This means "100 200" should be two separate additions, not "100 + 200"
                            if (bufferExpression.length > 0) {
                                const lastToken = bufferExpression[bufferExpression.length - 1];
                                if (typeof lastToken === 'number') {
                                    flushBuffer();
                                    // After flush, if currentOperator is not '+', re-inject it for the new number
                                    if (this.currentOperator !== '+') {
                                        bufferExpression.push(this.currentOperator);
                                    }
                                }
                            }

                            bufferExpression.push(val);
                        } else {
                            // If invalid (e.g. noise), flush previous buffer
                            flushBuffer();
                        }
                    });

                    // Flush remaining
                    flushBuffer();

                    if (addedCount > 0) {
                        this.render();
                        if (navigator.vibrate) navigator.vibrate(50);
                    }
                }

                evaluateExpression(tokens) {
                    if (tokens.length === 0) return null;

                    if (tokens.length === 1 && typeof tokens[0] === 'number') return tokens[0];

                    if (tokens[0] === '-' && tokens.length === 2 && typeof tokens[1] === 'number') return -tokens[1];

                    // * and / Logic: Apply to Total
                    if (['*', '/'].includes(tokens[0])) {
                        const currentTotal = this.calculateTotal();
                        if (tokens[0] === '*') {
                            // We want new Total = currentTotal * val.
                            // So we add: (currentTotal * val) - currentTotal
                            // The token stream usually is ["*", val].
                            if (tokens.length === 2 && typeof tokens[1] === 'number') {
                                const val = tokens[1];
                                return (currentTotal * val) - currentTotal;
                            }
                        } else if (tokens[0] === '/') {
                            if (tokens.length === 2 && typeof tokens[1] === 'number') {
                                const val = tokens[1];
                                if (val === 0) return null; // Div by zero
                                // New Total = currentTotal / val
                                // Add: (currentTotal / val) - currentTotal
                                return (currentTotal / val) - currentTotal;
                            }
                        }
                    }

                    try {
                        const expr = tokens.join(' ');
                        if (!/^[0-9\.\s\-\*\/]+$/.test(expr)) return null;
                        return new Function('return ' + expr)();
                    } catch (e) {
                        return null;
                    }
                }

                addEntry(value, label = null) {
                    const entry = {
                        id: Date.now(),
                        value: value,
                        label: label
                    };
                    this.entries.push(entry);
                    this.render();
                    this.updateOperatorUI(); // Ensure UI reflects state
                }
                parseNumber(str) {
                    // If pure numbers/dots (e.g. "0.03"), parse directly
                    if (/^[0-9\.]+$/.test(str)) {
                        return parseFloat(str);
                    }

                    const map = {
                        'é›¶': 0, 'ä¸€': 1, 'äºŒ': 2, 'å…©': 2, 'ä¸‰': 3, 'å››': 4,
                        'äº”': 5, 'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9, 'å': 10,
                        'ç™¾': 100, 'åƒ': 1000, 'è¬': 10000
                    };

                    // Split into integer part and decimal part if "." exists
                    const parts = str.split('.');
                    const integerPart = parts[0];
                    const decimalPart = parts[1];

                    let val = 0;

                    // Parse Integer Part
                    if (integerPart) {
                        if (/^[0-9]+$/.test(integerPart)) {
                            val = parseFloat(integerPart);
                        } else {
                            // Check if it contains any multipliers (å,ç™¾,åƒ,è¬)
                            const hasMultiplier = /[åç™¾åƒè¬]/.test(integerPart);

                            if (!hasMultiplier) {
                                // Digit-by-Digit Parsing (e.g. "å…­ä¹" -> 69)
                                let digitStr = '';
                                for (let i = 0; i < integerPart.length; i++) {
                                    const char = integerPart[i];
                                    if (/[0-9]/.test(char)) {
                                        digitStr += char;
                                    } else if (map[char] !== undefined) {
                                        digitStr += map[char];
                                    }
                                }
                                if (digitStr) val = parseFloat(digitStr);
                            } else {
                                // Standard Chinese Parsing (e.g. "å…­åä¹" -> 69)
                                let bucket = 0;
                                let currentDigitStr = '';

                                for (let i = 0; i < integerPart.length; i++) {
                                    const char = integerPart[i];

                                    if (/[0-9]/.test(char)) {
                                        currentDigitStr += char;
                                        continue;
                                    }

                                    if (currentDigitStr) {
                                        bucket = parseFloat(currentDigitStr);
                                        currentDigitStr = '';
                                    }

                                    const num = map[char];
                                    if (num === undefined) continue;

                                    if (num >= 10 && ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9].includes(num)) {
                                        if (bucket === 0 && char === 'å') bucket = 1;

                                        if (num === 10000) {
                                            val = (val + bucket) * 10000;
                                            bucket = 0;
                                        } else {
                                            val += bucket * num;
                                            bucket = 0;
                                        }
                                    } else {
                                        bucket = num;
                                    }
                                }
                                if (currentDigitStr) {
                                    bucket = parseFloat(currentDigitStr);
                                }
                                val += bucket;
                            }
                        }
                    }

                    // Parse Decimal Part (if exists)
                    if (decimalPart) {
                        // Chinese decimal reading is usually digit-by-digit: "é›¶é»é›¶ä¸‰" -> 0 . 0 3
                        let decimalValStr = '';
                        for (let i = 0; i < decimalPart.length; i++) {
                            const char = decimalPart[i];
                            if (/[0-9]/.test(char)) {
                                decimalValStr += char;
                            } else if (map[char] !== undefined && map[char] < 10) {
                                decimalValStr += map[char];
                            }
                        }
                        if (decimalValStr) {
                            val += parseFloat(`0.${decimalValStr}`);
                        }
                    }

                    return val === 0 && !str.includes('é›¶') && parseFloat(str) !== 0 ? NaN : val;
                }

                deleteLastEntry() {
                    if (this.entries.length > 0) {
                        const removed = this.entries.pop();
                        this.render();
                        this.showTranscript(`å·²åˆªé™¤ ${removed.value}`);
                    } else {
                        this.showTranscript('ç„¡è³‡æ–™');
                    }
                }

                clearAllEntries() {
                    if (this.entries.length > 0) {
                        this.entries = [];
                        this.render();
                        this.showTranscript('å·²å…¨éƒ¨æ¸…ç©º');
                        // Two distinct vibrations to confirm clear
                        if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
                    } else {
                        this.showTranscript('ç„¡è³‡æ–™ (ç„¡éœ€æ¸…ç©º)');
                    }
                }

                showSummary() {
                    this.updateTotal();
                    this.modalCount.textContent = this.entries.length;
                    this.modalTotal.textContent = this.calculateTotal().toLocaleString();
                    this.summaryModal.classList.remove('hidden');
                }

                calculateTotal() {
                    return this.entries.reduce((sum, item) => sum + item.value, 0);
                }

                updateTotal() {
                    const total = this.calculateTotal();
                    this.totalAmountEl.textContent = total.toLocaleString();
                    this.totalAreaLabel.textContent = `ç¸½è¨ˆ (${this.entries.length} ç­†)`;
                }

                render() {
                    this.updateTotal();
                    this.entriesList.innerHTML = '';

                    if (this.entries.length === 0) {
                        this.entriesList.innerHTML = `
                        <div class="empty-state">
                            <div style="text-align: left; display: inline-block; max-width: 90%; line-height: 1.6;">
                                <p style="margin-bottom: 8px;">â— è«‹æŒ‰é–‹å§‹èªªè©±ï¼Œç›¸åŠ åªéœ€å–Šæ•¸å­—<br>
                                    <span style="color: var(--text-secondary); font-size: 0.9em;">ä¾‹ã€Œ150 200 300ã€</span>
                                </p>
                                <p>â— èªªã€Œæ­¸é›¶ã€ã€Œå…¨æ¸…ã€ã€Œæ¸…é™¤ã€ã€Œå¹«æˆ‘æ­¸é›¶ã€ç•«é¢æœƒå…¨éƒ¨æ¸…é™¤</p>
                                <p style="margin-top: 8px; font-size: 0.8em; color: #888;">ç‰ˆæœ¬ v3.7 (ä½ˆå±€å¾®èª¿)</p>
                                <p style="margin-top: 8px; color: #4a90e2; font-weight: bold;">ç›®å‰æ¨¡å¼: <span id="mode-hint">åŠ æ³• (é è¨­)</span></p>
                            </div>
                        </div>
                    `;
                        setTimeout(() => this.updateOperatorUI(), 0);
                        return;
                    }

                    // Render newest first
                    this.entries.slice().reverse().forEach(entry => {
                        const li = document.createElement('div');
                        li.className = 'entry-item';

                        // Display Priority: Label > Explicit Sign > Standard
                        let displayValue;
                        if (entry.label) {
                            displayValue = entry.label;
                        } else {
                            displayValue = (entry.value >= 0 ? '' : '') + entry.value.toLocaleString();
                        }

                        li.innerHTML = `
                        <div class="entry-index">#${this.entries.indexOf(entry) + 1}</div>
                        <div class="entry-value ${entry.value < 0 && !entry.label ? 'negative' : ''}">
                            ${displayValue}
                        </div>
                        <button class="delete-btn" aria-label="åˆªé™¤">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    `;
                        li.querySelector('.delete-btn').addEventListener('click', () => {
                            this.entries = this.entries.filter(e => e.id !== entry.id);
                            this.render();
                        });
                        this.entriesList.appendChild(li);
                    });
                }
            }

            window.addEventListener('DOMContentLoaded', () => {
                new VoiceCalculator();
            });
        </script>
</body>

</html>