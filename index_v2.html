<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>語音加總計算機</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Operator Row Styling */
        .operator-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 0px;
            /* Merged visually with below */
            padding: 0 16px;
        }

        .operator-btn {
            background: #4a90e2;
            /* Blue */
            border: none;
            border-radius: 12px;
            width: 100%;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .operator-btn svg {
            color: white;
            width: 32px;
            height: 32px;
            stroke-width: 3;
        }

        .operator-btn.active {
            background: #2c3e50;
            /* Dark when active */
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 2px solid #4a90e2;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Settings Button -->
        <button id="btn-settings" class="settings-btn" aria-label="設定">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path
                    d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                </path>
            </svg>
        </button>

        <main id="entries-list" class="calc-list-container">
            <!-- Entries will be injected here -->
            <div class="empty-state">
                <div style="text-align: left; display: inline-block; max-width: 90%; line-height: 1.6;">
                    <p style="margin-bottom: 8px;">● 請按開始說話，相加只需喊數字<br>
                        <span style="color: var(--text-secondary); font-size: 0.9em;">例「150 200 300」</span>
                    </p>
                    <p>● 說「歸零」「全清」「清除」「幫我歸零」畫面會全部清除</p>
                    <p style="margin-top: 8px; font-size: 0.8em; color: #888;">版本 v2.0 (運算面板)</p>
                </div>
            </div>
        </main>

        <div id="live-transcript" class="transcript-overlay hidden"></div>
        <div id="status-indicator" class="status-pill">點擊麥克風</div>

        <div class="controls-area">
            <!-- Operator Row (New) -->
            <div class="operator-row">
                <button class="operator-btn active" id="btn-op-add" data-op="+">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="operator-btn" id="btn-op-sub" data-op="-">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="operator-btn" id="btn-op-mul" data-op="*">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                <button class="operator-btn" id="btn-op-div" data-op="/">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="16.88" y1="3.549" x2="7.12" y2="20.451"></line>
                    </svg>
                </button>
            </div>

            <div class="app-controls">
                <!-- Top Row: Total & Clear -->
                <div class="total-display-area">
                    <button id="btn-clear-all" class="status-badge"
                        style="background: white; color: var(--primary-color); border: none; font-weight: bold; display: flex; align-items: center; gap: 4px; padding: 6px 16px; cursor: pointer;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                        全清
                    </button>

                    <div style="text-align: right;">
                        <div class="total-label">總計 (0 筆)</div>
                        <div class="total-amount">
                            <span style="font-size: 1rem; vertical-align: middle;">NT$</span>
                            <span id="total-amount">0</span>
                        </div>
                    </div>
                </div>

                <!-- Bottom Row: Controls -->
                <div class="controls-row">
                    <button id="btn-delete" class="secondary-btn btn-delete" aria-label="刪除一筆">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path>
                            <line x1="18" y1="9" x2="12" y2="15"></line>
                            <line x1="12" y1="9" x2="18" y2="15"></line>
                        </svg>
                        <span>刪除</span>
                    </button>

                    <button id="mic-btn" class="mic-button" aria-label="開始/停止 錄音">
                        <div class="ripple-ring delay-1"></div>
                        <div class="ripple-ring"></div>
                        <div class="mic-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                <line x1="12" y1="19" x2="12" y2="23"></line>
                                <line x1="8" y1="23" x2="16" y2="23"></line>
                            </svg>
                        </div>
                    </button>

                    <button id="btn-summary" class="secondary-btn btn-summary" aria-label="結算">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="1" x2="12" y2="23"></line>
                            <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                        </svg>
                        <span>結算</span>
                    </button>
                </div>
            </div>

            <!-- Temporary Debug Bar -->
            <div id="debug-bar" style="
                margin-top: 10px;
                padding: 5px;
                background: #f0f0f0;
                color: #555;
                font-size: 0.8rem;
                text-align: center;
                border-radius: 4px;
                min-height: 20px;
                word-break: break-all;
            "></div>
        </div>
    </div>

    </div>

    <!-- Settings Modal -->
    <div id="summary-modal" class="modal hidden">
        <div class="modal-content">
            <h2>結算總覽</h2>
            <div class="modal-body">
                <div class="summary-row">
                    <span>總筆數</span>
                    <span id="modal-count" class="value">0</span>
                </div>
                <div class="summary-row total">
                    <span>總金額</span>
                    <span class="currency">NT$</span>
                    <span id="modal-total" class="value">0</span>
                </div>
            </div>
            <button id="close-modal-btn" class="primary-btn">關閉</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <h2>設定</h2>
            <div class="settings-body">
                <label for="auto-stop-select">閒置自動關閉 (分鐘)</label>
                <select id="auto-stop-select" class="styled-select">
                    <option value="1">1 分鐘</option>
                    <option value="2">2 分鐘</option>
                    <option value="3">3 分鐘</option>
                    <option value="5">5 分鐘</option>
                    <option value="10">10 分鐘</option>
                </select>
            </div>
            <button id="save-settings-btn" class="primary-btn">儲存</button>
        </div>
    </div>

    <script>
        class VoiceCalculator {
            constructor() {
                this.entries = [];
                this.isListening = false;
                this.recognition = null;
                this.currentOperator = '+'; // Default operator

                // Timers
                this.transcriptTimeout = null;
                this.forceFinalizeTimer = null;
                this.restartTimer = null;
                this.inactivityTimer = null; // Auto-stop timer

                // Config
                this.autoStopMinutes = 3; // Default 3 mins

                // DOM Elements
                this.statusIndicator = document.getElementById('status-indicator');
                this.settingsBtn = document.getElementById('btn-settings');
                this.entriesList = document.getElementById('entries-list');
                this.totalAmountEl = document.getElementById('total-amount');
                this.totalAreaLabel = document.querySelector('.total-label');
                this.micBtn = document.getElementById('mic-btn');
                this.summaryModal = document.getElementById('summary-modal');
                this.modalCount = document.getElementById('modal-count');
                this.modalTotal = document.getElementById('modal-total');
                this.closeModalBtn = document.getElementById('close-modal-btn');
                this.liveTranscript = document.getElementById('live-transcript');

                // Buttons
                this.btnDelete = document.getElementById('btn-delete');
                this.btnSummary = document.getElementById('btn-summary');
                this.btnClear = document.getElementById('btn-clear-all');

                this.initSpeechRecognition();
                this.initListeners();
                this.initOperatorButtons(); // New
                this.render();
                this.updateOperatorUI(); // Set initial active state and hint
            }

            initOperatorButtons() {
                const ops = document.querySelectorAll('.operator-btn');
                ops.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.currentOperator = btn.dataset.op;
                        this.updateOperatorUI();
                        if (navigator.vibrate) navigator.vibrate(30);
                    });
                });
            }

            updateOperatorUI() {
                document.querySelectorAll('.operator-btn').forEach(btn => {
                    if (btn.dataset.op === this.currentOperator) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // Update hints
                const hint = document.getElementById('mode-hint');
                if (hint) {
                    const textMap = { '+': '加法 (預設)', '-': '減法', '*': '乘法 (自動計算)', '/': '除法 (自動計算)' };
                    hint.textContent = textMap[this.currentOperator] || '加法';
                }
            }

            resetInactivityTimer() {
                if (this.inactivityTimer) clearTimeout(this.inactivityTimer);

                if (this.isListening) {
                    const ms = this.autoStopMinutes * 60 * 1000;
                    this.inactivityTimer = setTimeout(() => {
                        console.log('Inactivity timeout reached.');
                        this.isListening = false;
                        this.recognition.stop();
                        this.updateUIState(false);
                        this.statusIndicator.textContent = '閒置已關閉';
                        if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
                    }, ms);
                }
            }

            initSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();

                    // Continuous=true for smoother session. 
                    this.recognition.continuous = true;
                    this.recognition.lang = 'cmn-Hant-TW';
                    this.recognition.interimResults = true;
                    this.recognition.maxAlternatives = 1;

                    this.recognition.onstart = () => {
                        console.log('Voice Service: Started');
                        if (this.isListening) {
                            this.updateUIState(true);
                            if (navigator.vibrate) navigator.vibrate(50);
                            this.resetInactivityTimer();
                        }
                    };

                    this.recognition.onend = () => {
                        console.log('Voice Service: Ended');
                        // Vital: If we are supposed to be listening, restart immediately.
                        if (this.isListening) {
                            console.log('Voice Service: Auto-restarting...');

                            clearTimeout(this.restartTimer);
                            this.restartTimer = setTimeout(() => {
                                try {
                                    if (this.isListening) this.recognition.start();
                                } catch (e) {
                                    console.error("Restart failed", e);
                                }
                            }, 50);
                        } else {
                            this.updateUIState(false);
                        }
                    };

                    this.recognition.onresult = (event) => {
                        this.resetInactivityTimer();
                        clearTimeout(this.forceFinalizeTimer);

                        let finalTranscript = '';
                        let interimTranscript = '';

                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                finalTranscript += event.results[i][0].transcript;
                            } else {
                                interimTranscript += event.results[i][0].transcript;
                            }
                        }

                        if (finalTranscript) {
                            this.showTranscript(finalTranscript);
                            this.processSpeechInput(finalTranscript);
                        }

                        if (interimTranscript) {
                            this.showTranscript(interimTranscript);

                            // Eager Command Execution:
                            // If the user says a command, execute it immediately without waiting for finalization.
                            if (this.isCommand(interimTranscript)) {
                                console.log(`Eager Command Triggered: ${interimTranscript}`);
                                this.processSpeechInput(interimTranscript);

                                // Small delay before aborting to ensure UI updates are seen
                                setTimeout(() => this.recognition.abort(), 100);
                                return;
                            }

                            // Force finalize if stuck in interim state for > 0.2s (Extreme speed)
                            this.forceFinalizeTimer = setTimeout(() => {
                                console.log(`Force Finalizing: ${interimTranscript}`);
                                if (this.isListening) this.recognition.stop();
                            }, 200);
                        }
                    };

                    this.recognition.onerror = (event) => {
                        console.log(`Voice Service Error: ${event.error}`);

                        if (['no-speech', 'aborted', 'network'].includes(event.error)) {
                            return;
                        }

                        if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                            this.isListening = false;
                            this.updateUIState(false);
                            alert('無法存取麥克風。請確認：\n1. 網址開頭是 https\n2. 已允許瀏覽器使用麥克風');
                        } else {
                            this.statusIndicator.textContent = '錯誤: ' + event.error;
                        }
                    };
                } else {
                    alert('您的瀏覽器不支援語音辨識，請使用 Chrome (Android) 或 Safari (iOS)。');
                    this.micBtn.disabled = true;
                }
            }

            initListeners() {
                // Settings Button Logic
                if (this.settingsBtn) {
                    const settingsModal = document.getElementById('settings-modal');
                    const saveSettingsBtn = document.getElementById('save-settings-btn');
                    const autoStopSelect = document.getElementById('auto-stop-select');

                    this.settingsBtn.addEventListener('click', () => {
                        settingsModal.classList.remove('hidden');
                        autoStopSelect.value = this.autoStopMinutes;
                    });

                    saveSettingsBtn.addEventListener('click', () => {
                        const val = parseInt(autoStopSelect.value);
                        this.autoStopMinutes = val;
                        settingsModal.classList.add('hidden');
                        this.showTranscript(`已設定: ${val} 分鐘`);
                        if (this.isListening) this.resetInactivityTimer();
                    });

                    settingsModal.addEventListener('click', (e) => {
                        if (e.target === settingsModal) settingsModal.classList.add('hidden');
                    });
                }

                this.micBtn.addEventListener('click', () => {
                    if (navigator.vibrate) navigator.vibrate(30);

                    if (this.isListening) {
                        // User wants to STOP
                        this.isListening = false;
                        this.recognition.stop();
                        this.updateUIState(false);
                        if (this.inactivityTimer) clearTimeout(this.inactivityTimer);
                    } else {
                        // User wants to START
                        this.isListening = true;
                        this.statusIndicator.textContent = '啟動中...';
                        try { this.recognition.abort(); } catch (e) { }

                        setTimeout(() => {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                console.error("Start failed", e);
                                this.isListening = false;
                                this.updateUIState(false);
                                alert('啟動失敗，請重試');
                            }
                        }, 100);
                    }
                });

                this.btnDelete.addEventListener('click', () => this.deleteLastEntry());
                this.btnSummary.addEventListener('click', () => this.showSummary());

                this.btnClear.addEventListener('click', () => {
                    if (this.entries.length > 0 && confirm('確定清空所有數字？')) {
                        this.clearAllEntries();
                    } else if (this.entries.length === 0) {
                        this.showTranscript('無資料');
                    }
                });

                this.closeModalBtn.addEventListener('click', () => this.summaryModal.classList.add('hidden'));
                this.summaryModal.addEventListener('click', (e) => {
                    if (e.target === this.summaryModal) this.summaryModal.classList.add('hidden');
                });
            }

            updateUIState(listening, customText) {
                if (listening) {
                    this.micBtn.classList.add('listening');
                    this.statusIndicator.textContent = customText || '聆聽中...';
                    this.statusIndicator.classList.add('listening');
                } else {
                    this.micBtn.classList.remove('listening');
                    this.statusIndicator.textContent = '系統已更新 (準備就緒)';
                    setTimeout(() => {
                        this.updateUIState(false);
                    }, 2000);
                    this.statusIndicator.classList.remove('listening');
                    this.hideTranscript();
                }
            }

            showTranscript(text) {
                this.liveTranscript.textContent = text;
                this.liveTranscript.classList.remove('hidden');
                if (this.transcriptTimeout) clearTimeout(this.transcriptTimeout);
                this.transcriptTimeout = setTimeout(() => this.hideTranscript(), 2000);
            }

            hideTranscript() {
                this.liveTranscript.classList.add('hidden');
            }

            isCommand(text) {
                if (!text) return false;
                const lower = text.toLowerCase();
                return text.includes('清除') || text.includes('全清') || text.includes('歸零') || text.includes('清楚') || text.includes('歸0') || text.includes('幫我歸零') ||
                    text.includes('總共') || text.includes('多少') || text.includes('結算') || text.includes('買單') || text.includes('此單') ||
                    text.includes('刪除') || lower.includes('delete');
            }

            processSpeechInput(text) {
                let cleanText = text.trim();
                cleanText = cleanText.replace(/,/g, '');
                if (!cleanText) return;

                // --- Debug Logging (Raw) ---
                const debugBar = document.getElementById('debug-bar');
                if (debugBar) {
                    debugBar.textContent = `聽見: ${cleanText} | 模式: ${this.currentOperator}`;
                }

                // Command: Delete
                if (cleanText.includes('刪除') || cleanText.toLowerCase().includes('delete')) {
                    this.deleteLastEntry();
                    return;
                }

                // Command: Clear All
                if (cleanText.includes('清除') || cleanText.includes('全清') || cleanText.includes('歸零') || cleanText.includes('清楚') || cleanText.includes('歸0') || cleanText.includes('幫我歸零')) {
                    this.clearAllEntries();
                    return;
                }

                // Command: Summary
                if (cleanText.includes('總共') || cleanText.includes('多少') || cleanText.includes('結算') || cleanText.includes('買單') || cleanText.includes('此單')) {
                    this.showSummary();
                    return;
                }

                // --- Arithmetic Pre-processing ---
                // We keep the old normalization just in case, but we prioritize the UI operator
                cleanText = cleanText.replace(/減去|扣掉|扣除|減|➖|－|﹣/g, ' - ');
                cleanText = cleanText.replace(/乘以|乘上|乘|✖️|x|X|成|×|＊|Ｘ|ｘ/g, ' * ');
                cleanText = cleanText.replace(/除以|除|➗|÷|／/g, ' / ');
                cleanText = cleanText.replace(/加|＋/g, ' + ');
                cleanText = cleanText.replace(/點|。|．|·/g, '.');

                // Split by anything that isn't a Number char, Operator, or Dot
                const tokens = cleanText.split(/[^0-9零一二兩三四五六七八九十百千萬\.\-\*\/\+]+/);

                if (debugBar) {
                    debugBar.textContent += ` | 處理後: ${cleanText} | Token: [${tokens.join(', ')}]`;
                }

                let addedCount = 0;
                let bufferExpression = [];

                const flushBuffer = () => {
                    if (bufferExpression.length > 0) {
                        try {
                            const result = this.evaluateExpression(bufferExpression);
                            if (result !== null && !isNaN(result)) {
                                this.addEntry(result);
                                addedCount++;
                                if (debugBar) debugBar.textContent += ` | 結果: ${result}`;
                            } else {
                                if (debugBar) debugBar.textContent += ` | 無效運算`;
                            }
                        } catch (e) {
                            if (debugBar) debugBar.textContent += ` | 錯誤: ${e.message}`;
                        }
                        bufferExpression = [];
                    }
                };

                tokens.forEach(token => {
                    token = token.trim();
                    if (!token) return;

                    // If token is an operator (explicitly spoken)
                    if (['-', '*', '/', '+'].includes(token)) {
                        // If there's a number before this operator, flush it first
                        if (bufferExpression.length > 0 && typeof bufferExpression[bufferExpression.length - 1] === 'number') {
                            flushBuffer();
                        }
                        bufferExpression.push(token);
                        return;
                    }

                    // Attempt number parse
                    let val = this.parseNumber(token);

                    // If valid number
                    if (!isNaN(val)) {
                        // Apply Current Operator Logic if no explicit operator was spoken
                        // If buffer is empty or the last token was a number (implying a new operation)
                        // and the current operator is not '+', prepend the current operator.
                        if (this.currentOperator !== '+' && (bufferExpression.length === 0 || typeof bufferExpression[bufferExpression.length - 1] === 'number')) {
                            // If the last item was a number, flush it first to start a new operation
                            if (typeof bufferExpression[bufferExpression.length - 1] === 'number') {
                                flushBuffer();
                            }
                            bufferExpression.push(this.currentOperator);
                        }

                        // Check if previous item in buffer was ALSO a number (Implicit break)
                        // This means "100 200" should be two separate additions, not "100 + 200"
                        if (bufferExpression.length > 0) {
                            const lastToken = bufferExpression[bufferExpression.length - 1];
                            if (typeof lastToken === 'number') {
                                flushBuffer();
                                // After flush, if currentOperator is not '+', re-inject it for the new number
                                if (this.currentOperator !== '+') {
                                    bufferExpression.push(this.currentOperator);
                                }
                            }
                        }

                        bufferExpression.push(val);
                    } else {
                        // If invalid (e.g. noise), flush previous buffer
                        flushBuffer();
                    }
                });

                // Flush remaining
                flushBuffer();

                if (addedCount > 0) {
                    this.render();
                    if (navigator.vibrate) navigator.vibrate(50);

                    // Auto-reset to Plus after one-shot? 
                    // User said "若選X所有列表數字會相乘", implying a sticky mode.
                    // Let's keep it Sticky for now.
                }
            }

            evaluateExpression(tokens) {
                if (tokens.length === 0) return null;

                // Case 1: Single Number
                if (tokens.length === 1 && typeof tokens[0] === 'number') {
                    return tokens[0];
                }

                // Case 2: Negative Number (Unary -)
                // e.g. ["-", 150] -> -150
                // We prefer this over "Ans - 150" for simple lists
                if (tokens[0] === '-' && tokens.length === 2 && typeof tokens[1] === 'number') {
                    return -tokens[1];
                }

                // Case 3: Stateful Arithmetic (Ans * x, Ans / x)
                // If it starts with * or /, prepend the last entry value
                if (['*', '/'].includes(tokens[0])) {
                    if (this.entries.length > 0) {
                        const lastValue = this.entries[this.entries.length - 1].value;
                        tokens.unshift(lastValue);
                    } else {
                        // No previous entry to operate on
                        return null;
                    }
                }

                // Case 4: General Expression
                try {
                    const expr = tokens.join(' ');
                    // Security check: expr should only contain digits, ., -, *, /, space
                    if (!/^[0-9\.\s\-\*\/]+$/.test(expr)) return null;

                    // Use Function constructor for safer eval
                    return new Function('return ' + expr)();
                } catch (e) {
                    console.error("Math error", e);
                    return null;
                }
            }

            addEntry(val) {
                this.entries.push({
                    id: Date.now() + Math.random(),
                    value: val,
                    timestamp: new Date()
                });
            }

            parseNumber(str) {
                // If pure numbers/dots (e.g. "0.03"), parse directly
                if (/^[0-9\.]+$/.test(str)) {
                    return parseFloat(str);
                }

                // If mixed or Chinese
                const map = {
                    '零': 0, '一': 1, '二': 2, '兩': 2, '三': 3, '四': 4,
                    '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10,
                    '百': 100, '千': 1000, '萬': 10000
                };

                // Split into integer part and decimal part if "." exists
                const parts = str.split('.');
                const integerPart = parts[0];
                const decimalPart = parts[1];

                let val = 0;

                // Parse Integer Part
                if (integerPart) {
                    if (/^[0-9]+$/.test(integerPart)) {
                        val = parseFloat(integerPart);
                    } else {
                        // Chinese parsing for integer
                        let bucket = 0;
                        let currentDigitStr = '';

                        for (let i = 0; i < integerPart.length; i++) {
                            const char = integerPart[i];

                            if (/[0-9]/.test(char)) {
                                currentDigitStr += char;
                                continue;
                            }

                            if (currentDigitStr) {
                                bucket = parseFloat(currentDigitStr);
                                currentDigitStr = '';
                            }

                            const num = map[char];
                            if (num === undefined) continue;

                            if (num >= 10 && ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9].includes(num)) {
                                if (bucket === 0 && char === '十') bucket = 1;

                                if (num === 10000) {
                                    val = (val + bucket) * 10000;
                                    bucket = 0;
                                } else {
                                    val += bucket * num;
                                    bucket = 0;
                                }
                            } else {
                                bucket = num;
                            }
                        }
                        if (currentDigitStr) {
                            bucket = parseFloat(currentDigitStr);
                        }
                        val += bucket;
                    }
                }

                // Parse Decimal Part (if exists)
                if (decimalPart) {
                    // Chinese decimal reading is usually digit-by-digit: "零點零三" -> 0 . 0 3
                    let decimalValStr = '';
                    for (let i = 0; i < decimalPart.length; i++) {
                        const char = decimalPart[i];
                        if (/[0-9]/.test(char)) {
                            decimalValStr += char;
                        } else if (map[char] !== undefined && map[char] < 10) {
                            decimalValStr += map[char];
                        }
                    }
                    if (decimalValStr) {
                        val += parseFloat(`0.${decimalValStr}`);
                    }
                }

                return val === 0 && !str.includes('零') && parseFloat(str) !== 0 ? NaN : val;
            }

            deleteLastEntry() {
                if (this.entries.length > 0) {
                    const removed = this.entries.pop();
                    this.render();
                    this.showTranscript(`已刪除 ${removed.value}`);
                } else {
                    this.showTranscript('無資料');
                }
            }

            clearAllEntries() {
                if (this.entries.length > 0) {
                    this.entries = [];
                    this.render();
                    this.showTranscript('已全部清空');
                    // Two distinct vibrations to confirm clear
                    if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
                } else {
                    this.showTranscript('無資料 (無需清空)');
                }
            }

            showSummary() {
                this.updateTotal();
                this.modalCount.textContent = this.entries.length;
                this.modalTotal.textContent = this.calculateTotal().toLocaleString();
                this.summaryModal.classList.remove('hidden');
            }

            calculateTotal() {
                return this.entries.reduce((sum, item) => sum + item.value, 0);
            }

            updateTotal() {
                const total = this.calculateTotal();
                this.totalAmountEl.textContent = total.toLocaleString();
                this.totalAreaLabel.textContent = `總計 (${this.entries.length} 筆)`;
            }

            render() {
                this.updateTotal();
                this.entriesList.innerHTML = '';

                if (this.entries.length === 0) {
                    this.entriesList.innerHTML = `
                        <div class="empty-state">
                           <div style="text-align: left; display: inline-block; max-width: 90%; line-height: 1.6;">
                                <p style="margin-bottom: 8px;">● 請按開始說話相加只需喊數字<br>
                                    <span style="color: var(--text-secondary); font-size: 0.9em;">例「150 200 300」</span>
                                </p>
                                <p style="margin-bottom: 8px;">● 減/乘/除 法須加「減」「乘」「除」加數字<br>
                                    <span style="color: var(--text-secondary); font-size: 0.9em;">例「減150 乘200 除300」</span>
                                </p>
                                <p>● 說「歸零」「全清」「清除」「幫我歸零」畫面會全部清除</p>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Render newest first
                [...this.entries].reverse().forEach((entry, index) => {
                    const displayIndex = this.entries.length - index;
                    const el = document.createElement('div');
                    el.className = 'entry-item';
                    el.innerHTML = `
                        <span class="entry-index">#${displayIndex}</span>
                        <span class="entry-value">${entry.value.toLocaleString()}</span>
                        <button class="delete-btn" aria-label="刪除">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    `;
                    el.querySelector('.delete-btn').addEventListener('click', () => {
                        this.entries = this.entries.filter(e => e.id !== entry.id);
                        this.render();
                    });
                    this.entriesList.appendChild(el);
                });
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new VoiceCalculator();
        });
    </script>
</body>

</html>